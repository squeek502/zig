//! This file is auto-generated by tools/update_cpu_features.zig.

const std = @import("../std.zig");
const CpuFeature = std.Target.Cpu.Feature;
const CpuModel = std.Target.Cpu.Model;

pub const Feature = enum {
    atomics,
    bulk_memory,
    exception_handling,
    extended_const,
    multimemory,
    multivalue,
    mutable_globals,
    nontrapping_fptoint,
    reference_types,
    relaxed_simd,
    sign_ext,
    simd128,
    tail_call,
};

pub const featureSet = CpuFeature.feature_set_fns(Feature).featureSet;
pub const featureSetHas = CpuFeature.feature_set_fns(Feature).featureSetHas;
pub const featureSetHasAny = CpuFeature.feature_set_fns(Feature).featureSetHasAny;
pub const featureSetHasAll = CpuFeature.feature_set_fns(Feature).featureSetHasAll;

pub const all_features = blk: {
    const len = @typeInfo(Feature).Enum.fields.len;
    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);
    var result: [len]CpuFeature = undefined;
    result[@intFromEnum(Feature.atomics)] = .{
        .llvm_name = "atomics",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.bulk_memory)] = .{
        .llvm_name = "bulk-memory",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.exception_handling)] = .{
        .llvm_name = "exception-handling",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.extended_const)] = .{
        .llvm_name = "extended-const",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.multimemory)] = .{
        .llvm_name = "multimemory",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.multivalue)] = .{
        .llvm_name = "multivalue",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.mutable_globals)] = .{
        .llvm_name = "mutable-globals",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.nontrapping_fptoint)] = .{
        .llvm_name = "nontrapping-fptoint",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.reference_types)] = .{
        .llvm_name = "reference-types",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.relaxed_simd)] = .{
        .llvm_name = "relaxed-simd",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.sign_ext)] = .{
        .llvm_name = "sign-ext",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.simd128)] = .{
        .llvm_name = "simd128",
        .dependencies = featureSet(&[_]Feature{}),
    };
    result[@intFromEnum(Feature.tail_call)] = .{
        .llvm_name = "tail-call",
        .dependencies = featureSet(&[_]Feature{}),
    };
    const ti = @typeInfo(Feature);
    for (&result, 0..) |*elem, i| {
        elem.index = i;
        elem.name = ti.Enum.fields[i].name;
    }
    break :blk result;
};

pub const feature_descs = blk: {
    const len = @typeInfo(Feature).Enum.fields.len;
    var result: [len][]const u8 = undefined;
    result[@intFromEnum(Feature.atomics)] = "Enable Atomics";
    result[@intFromEnum(Feature.bulk_memory)] = "Enable bulk memory operations";
    result[@intFromEnum(Feature.exception_handling)] = "Enable Wasm exception handling";
    result[@intFromEnum(Feature.extended_const)] = "Enable extended const expressions";
    result[@intFromEnum(Feature.multimemory)] = "Enable multiple memories";
    result[@intFromEnum(Feature.multivalue)] = "Enable multivalue blocks, instructions, and functions";
    result[@intFromEnum(Feature.mutable_globals)] = "Enable mutable globals";
    result[@intFromEnum(Feature.nontrapping_fptoint)] = "Enable non-trapping float-to-int conversion operators";
    result[@intFromEnum(Feature.reference_types)] = "Enable reference types";
    result[@intFromEnum(Feature.relaxed_simd)] = "Enable relaxed-simd instructions";
    result[@intFromEnum(Feature.sign_ext)] = "Enable sign extension operators";
    result[@intFromEnum(Feature.simd128)] = "Enable 128-bit SIMD";
    result[@intFromEnum(Feature.tail_call)] = "Enable tail call instructions";
    break :blk result;
};

pub const cpu = struct {
    pub const bleeding_edge = CpuModel{
        .name = "bleeding_edge",
        .llvm_name = "bleeding-edge",
        .features = featureSet(&[_]Feature{
            .atomics,
            .bulk_memory,
            .mutable_globals,
            .nontrapping_fptoint,
            .sign_ext,
            .simd128,
            .tail_call,
        }),
    };
    pub const generic = CpuModel{
        .name = "generic",
        .llvm_name = "generic",
        .features = featureSet(&[_]Feature{
            .mutable_globals,
            .sign_ext,
        }),
    };
    pub const mvp = CpuModel{
        .name = "mvp",
        .llvm_name = "mvp",
        .features = featureSet(&[_]Feature{}),
    };
};
